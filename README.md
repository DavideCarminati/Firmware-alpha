# Firmware alpha
This repository is an open-source autopilot developed with PlatformIO and Visual Studio Code. It is compatible with [ARM&reg; Mbed&trade; OS](https://os.mbed.com/mbed-os/) and makes use of its APIs. The autopilot is tested on a [NXP FRDM-K64F](https://os.mbed.com/platforms/FRDM-K64F/) board. 
## Processor-In-the-Loop (PIL)
*Processor-In-the-Loop* validation allows the developer to test the software directly on the target board. The board is connected with an external PC on which is running the physical model of the robot as well as a model of its actuators and sensors.
This firmware supports communication using the **UDP** protocol to talk with the external PC. The connection properties (e.g. IP, Port...) can be modified in the file *UDPComm.cpp*:
````c++
static const char*          mbedIP       = "192.168.1.55";      // This board IP seen from the network
static const char*          mbedMask     = "255.255.255.0";     // Mask
static const char*          mbedGateway  = "192.168.1.254";     // Gateway

static const char*          recvIP = "192.168.1.203";           // External PC IP */ "192.168.1.249";
static const char*          localIP = "0.0.0.0";                // Local IP on which the server of the board listens
````
The messaging protocol used is [Mavlink v2.0](https://mavlink.io/en/) since it is lightweight, open-source and widespread.
### PIL with Matlab/Simulink&reg;
It is possible to employ Simulink to create the robot model

## Code generation with Matlab/Simulink&reg;
For *Rapid Prototyping* purposes, code generation is a valid tool. The Firmware is compatible with C/C++ code automatically generated from Matlab/Simulink&reg;. Here general rules and the settings used in the **Model Configuration Parameter** pane are shown so that scripts generated by the embedded coder in Simulink are compatible with the Firmware.
#### General rules
The following general rules have to be taken into account when creating the Simulink model:
* To match the variable names in the Firmware, the Simulink model has to be named "*feedback_control.slx*", so that input and output variables are structs named respectively *feedback_control_U* and *feedback_control_Y*;
* The **In1** and **Out1** ports in Simulink has to be carefully named since the arguments of the C++ controller step function are structs whose members take the name from those ports.
#### Interface

### Firmware with generated code 
The generated code can be easily added to the Firmware by doing a copy and paste of the header files into the *include* folder and the source files into the *src* folder. Then, few modifications have to be done to make the Firmware compatible with some generated code:
* Look throughout the scripts depending on the header *global_vars.hpp* and add the *feedback_control_U* and *feedback_control_Y* structs